INSTALL postgres;LOAD postgres;ATTACH 'postgresql://ae_interview:password@localhost:5432/analytics_db' AS pg (TYPE postgres);select 1;select * from pg.raw.events;select * from raw.test;select * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/events-company-1.csv';create table pg.raw.test26 as select event_id "event_id_lower", event_id "EVENT_ID_UPPER", event_id event_id_not_quoted, * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/events-company-1.csv';SET preserve_identifier_case=false;create table pg.raw.test27 as select * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/events-company-1.csv';describe select * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/events-company-1.csv';describe select * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/tmp.csv';describe select * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/tmp2.csv';create table pg.raw.test29 as select * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/tmp.csv';create table pg.raw.test29 as select * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/tmp2.csv';create table pg.raw.test28 as select 324 ID, 34234 id_lower; --> both lower caseselect  * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/*.csv';SELECT *FROM read_csv(  '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/*.csv',  filename = TRUE);SELECT * FROM glob('/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/*.csv');SELECT * FROM glob('/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/*/*');select * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/*.csv' union allselect * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/*.parquet';-- ustvari testno tabelo v Postgresselect * from pg.raw.test_copy;create schema pg.raw;CREATE TABLE pg.raw.test_copy(id INT, name TEXT);insert into pg.raw.test_copy (id, name) values (1222,'fdsa');CREATE TABLE pg.raw.test_copy(id INT, name TEXT);CREATE TABLE pg.raw.test_copy2(id TEXT, name TEXT);-- poskusi COPY ->> ok, to dela! ampak pie v fajlCOPY (SELECT event_id, type FROM read_parquet('/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/*.parquet')) TO 'filename.txt'; --> write to file!!select * from pg.raw.test_copy2;select count(*) from pg.raw.test_copy2;truncate table pg.raw.test_copy2;select count(*) from pg.raw.events2;--- ok, this works!create table pg.raw.test_copy3 as select * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/*.parquet' where 1=0;copy pg.raw.test_copy3 from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/*.parquet';select count(*) from pg.raw.test_copy3 ;-- not supported sub-selectscopy pg.raw.test_copy2 from (    select event_id, type    FROM read_parquet('/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/*.parquet'));insert into pg.raw.test_copy2SELECT event_id, type FROM read_parquet('/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/*.parquet');select    tab.event_id, count(*) cntfrom (select * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/*.parquet') tabgroup by tab.event_idorder by cnt desc;select * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/events-company-1.csv';select * from pg.raw.events_csv;copy pg.raw.test_copy3 from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/*.parquet';----- benchmark-- 1. Generate synthetic data: 10M rows with 5 random columnscreate table bench_data asselect    range as id,    random() as col_a,    random() as col_b,    random() as col_c,    md5(random()::varchar) as col_d,    (random() * 1000)::int as col_efrom range(10000000);-- 2. create tablescreate table pg.raw.bench_insert as select * from bench_data where 1=0;create table pg.raw.bench_copy   as select * from bench_data where 1=0;-- 3. benchmark 1: insert into … select * from read_parquet-- 10,000,000 rows affected in 22 s 263 ms-- 10,000,000 rows affected in 25 s 46 msinsert into pg.raw.bench_insert select * from read_parquet('/tmp/gen_data_10m.parquet');-- 3. benchmark 2: copy … from parquet-- 10,000,000 rows affected in 21 s 479 ms-- 10,000,000 rows affected in 25 s 154 mscopy pg.raw.bench_copy from '/tmp/gen_data_10m.parquet' (format 'parquet');-- 4. sanity check: row countsselect  (select count(*) from pg.raw.bench_insert) as insert_count,  (select count(*) from pg.raw.bench_copy) as copy_count;  select current_timestamp;  ----  copy pg.raw.events2 from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/*.parquet';  select * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/*.parquet';  select * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/*.csv';drop table pg.raw.bench_copy;drop table pg.raw.bench_insert;drop table pg.raw.events2;drop table pg.raw.events_csv;select    *,    now()::timestamp as load_ts,    filenamefrom '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/*.csv';-- EVENT_ID (string/UUID): Unique identifier for each event-- TYPE (string): Type of event. Common values include:-- consent.given - User has granted consent (most common: ~57% of events)-- pageview - Page view event (~27% of events)-- consent.asked - Consent prompt was shown (~14% of events)-- ui.action - User interface interaction (~3% of events)-- RATE (float): Sampling rate for the event (e.g., 0.1 means 10% sample rate, 1 means 100%)-- PARAMETERS (string/JSON): JSON object containing detailed event parameters. Structure varies by event type:-- For consent.given and consent.asked: Contains nested objects with purposes, vendors, and previous states-- For pageview and ui.action: Often empty-- EVENT_TIME (timestamp): When the event occurred (format: YYYY-MM-DD HH:MM:SS.mmm)-- WINDOW_START (timestamp): Start of the aggregation time window (format: YYYY-MM-DD HH:MM:SS.mmm)-- APIKEY (string/UUID): Company identifier - foreign key to PUBLIC_API_KEY in the company information file-- CONSENT (string): User's consent status (e.g., "full opt-in", "empty", "partial")-- COUNT (integer): Event count (often represents aggregated events)-- EXPERIMENT (string): Experiment/A-B test identifier (can be empty)-- SDK_TYPE (string): SDK type used to track the event (e.g., "sdk-mobile", "sdk-web")-- DOMAIN (string): Domain where the event occurred (e.g., "service1.org")-- DEPLOYMENT_ID (string): Deployment identifier (can be empty)-- COUNTRY (string): Country code(s) where event originated, enclosed in triple quotes (e.g., """ES""", """FR""")-- REGION (string): Region code where event originated, enclosed in triple quotes (e.g., """CM""", """MD""")-- BROWSER_FAMILY (string): Browser or SDK identifier (e.g., "Didomi SDK", "Chrome", "Safari")-- DEVICE_TYPE (string): Type of device (e.g., "smartphone", "desktop", "tablet")select * from pg.raw.events_csv;select event_id, count(*) cnt from pg.raw.events_csv group by 1 order by cnt desc;create table if not exists pg.raw.events(    event_id       varchar,    type           varchar,    rate           double precision,    parameters     varchar,    event_time     varchar,    window_start   varchar,    apikey         varchar,    consent        varchar,    count          bigint,    experiment     double precision,    sdk_type       varchar,    domain         varchar,    deployment_id  varchar,    country        varchar,    region         varchar,    browser_family varchar,    device_type    varchar);SELECT *, now()::timestamp AS load_ts, filename            FROM '{filename}'            LIMIT 0;drop table pg.raw.events;select * from pg.raw.events_csv;select * from pg.raw.test;drop table meta;create or replace table meta asselect unnest(['file1']) as filename, current_timestamp as load_time, 'loaded' status;select unnest(['file1', 'file2', 'file3', 'file4']) as filename, 'events' table_nameexceptselect    filename, table_namefrom metawhere status = 'loaded';select * from pg.raw.test8;select count(*) from pg.raw.test8;select * from meta;select * from load_metadata;SELECT database_name, schema_name, table_nameFROM duckdb_tables();WHERE table_name = 'load_metadata';select * from raw.load_metadata;select * from pg.raw.test9;-- insert into pg.raw.test9select t.*, current_timestamp as load_time, 'xx' as load_no, 'fdsafd' as filenameselect count(*)from    ['/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/events-company-9.parquet',    '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/events-company-9.parquet']    t;-- no, go. it creates a lock!ATTACH '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/scripts/load_metadata.duckdb'  as meta (READ_ONLY);detach meta; -- direcly after detaching it works againselect 1;select * from meta.load_metadata;drop table pg.raw.test9;drop table pg.raw.test10;drop table pg.raw.test11;drop table pg.raw.test12_country;drop table pg.raw.test13_country;drop table pb.raw.country_and_industry;drop table pb.raw.events;select * from pg.raw.country_and_industry;-------------   company dim?    select        "PUBLIC_API_KEY" company_id,        "INDUSTRY_BACK" industry_back,        "INDUSTRY_FRONT" industry_front,        "HQ_COUNTRY" hq_country,        load_time,        load_no,        filename    from country_and_industryselect * from country_and_industry;select * from mart.company_dim;select * from mart.country_dim;select * from staging.stg_country;select * from staging.stg_company;select * from raw.events;--------  ANALYSIS QUALITY DIRECLY ON POSTGRESwith raw_company as (    select        "PUBLIC_API_KEY" company_id,        "INDUSTRY_BACK" industry_back,        "INDUSTRY_FRONT" industry_front,        "HQ_COUNTRY" hq_country,        load_time,        load_no,        filename    from country_and_industry), raw_events as (    select        "EVENT_ID" event_id,        "USER_ID" user_id,        "TYPE" type,        "RATE" rate,        "PARAMETERS" parameters,        "EVENT_TIME" event_time,        "WINDOW_START" window_start,        "APIKEY" apikey,        "CONSENT" consent,        "COUNT" count,        "EXPERIMENT" experiment,        "SDK_TYPE" sdk_type,        "DOMAIN" domain,        "DEPLOYMENT_ID" deployment_id,        "COUNTRY" country,        "REGION" region,        "BROWSER_FAMILY" browser_family,        "DEVICE_TYPE" device_type,        load_time,        load_no,        filename    from events), trf_events as (    select       *    from raw_events)-- check data-- select * from raw_company-- No duplicated companies-- select company_id,  count(*) cnt from raw group by 1 order by cnt desc;-- ISSUE: 7/40 are missing the hq_country (null)-------- let's check events structure-- we have in total 5274 events-- select count(*) from raw_events-- select * from raw_events-- NO DUPLICATES-- select event_id,  count(*) cnt from raw_events group by 1 order by cnt desc;-- select * from raw_events-- COMPANIES-- select apikey, count(*) cnt from raw_events group by 1 order by cnt desc; --> only 10 companies in this example!!-- are all of them in coompanies? Yeap, all of them are hjere. currently they have 1500 CLIENTS (found on the web) -> daily periodic snapshots could work fine if we would need this..-- select * from raw_company where company_id IN ('8f7daf45-489f-49e4-89c8-5f9a296b275c', 'e1ac7e0c-53a5-4663-ac8a-ce98545817ec', 'da552ba1-4bf9-42e7-befa-6c7f389f1b65', '49af23d9-0cad-4d42-8adc-744791443345', 'e30f9a7e-1068-4cbe-ac99-41a618d38f48', '7725cda3-efd1-440b-8cc4-f80972acee43', 'f921ddae-7bbc-4132-a9dd-04683bb89c2d', '5f67fa3a-b292-4bd2-b6e0-52257adc3a3b', 'eb3fdba4-7b9b-4c5e-9a81-7ed2918ff46e', '29b2ad43-be6b-441a-9324-038b9268c9b6');select * from raw_events-- select type, rate, consent, count(*) cnt from raw_events group by 1,2,3 order by cnt desc;;-- select type, rate, consent, count(*) cnt from raw_events group by 1,2,3 order by cnt desc;;;-- ok, good sourceselect * from raw.countries-- ok, all are thereSELECT *FROM (    SELECT DISTINCT BTRIM("COUNTRY", '"') AS country_code    FROM raw.events) AS eWHERE country_code IN (    SELECT country_code    FROM raw.countries);SELECT gen_random_uuid() AS id;-- QUESTIONS-- Metrics--   Distribution of consent statuses: I suppose that the metric should only be based on `consent.given` event type? Or also an `ui.action` events can lead to a consent and should be counted as such?--   Time between consent being asked and consent being given: To accurately calculate this metric we would need a non-sampled `consent.asked` type events. Additionallly data should include a common key (eg. anononymised user_id or session_id) to correctly associate events for this user. Is this metric still relevant for this assignment?-- Data quality questions-- +-------------+--------------+----+-- |type         |consent       |cnt |-- +-------------+--------------+----+-- |consent.asked|empty         |541 |-- |consent.asked|full opt-in   |6   | --> a) Are non-empty consent values a valid case for  `consent.asked` events? Based on that in this stage only a banner or popup is displayed to the user I assume they are probably quality issues as the consent has not been collectee yet?-- |consent.asked|opt-out       |2   |-- |consent.asked|partial opt-in|2   |-- |consent.given|empty         |269 | --> b) Is a given empty consent a valid consent or a data anomaly (eg. SDK collection issue)? How can we interpret an empty given consent?-- |consent.given|full opt-in   |1884|-- |consent.given|opt-out       |591 |-- |consent.given|partial opt-in|91  |-- |pageview     |empty         |384 |-- |pageview     |full opt-in   |405 |--> c) How can we interpret non-empty consents on pageview events? Are these collection anomalies or just last user statuses that were set in the previous steps?-- |pageview     |opt-out       |185 |-- |pageview     |partial opt-in|195 |-- |ui.action    |empty         |195 |--> d) How can we interpret non-empty consents on ui.action events?-- |ui.action    |full opt-in   |4   |-- |ui.action    |opt-out       |4   |-- +-------------+--------------+----+action - purpose change!-- CHECK CONSENT GIVEn! rate shouldn' be sampled! --> ok--- Ovservation---   poglej ratio consent.asked vs givenevent_id	STRING	1c269ade-d654-4374-aafb-3deaebe5376bevent_datetime	TIMESTAMP	2021-01-23 10:23:51domain	STRING	www.domain-A.euevent_type	STRING	consent.givenuser_id	STRING	1705c98b-367c-6d09-a30f-da9e6f4da700user_country	STRING	FRvendor_enabled	ARRAY<STRING>	["Vendor1"]vendor_disabled	ARRAY<STRING>	[]purpose_enabled	ARRAY<STRING>	["analytics"]purpose_disabled	ARRAY<STRING>	[];with raw as    select        "EVENT_ID" event_id,        "USER_ID" user_id,        "TYPE" type,        "RATE" rate,        "PARAMETERS" parameters,        "EVENT_TIME" event_time,        "WINDOW_START" window_start,        "APIKEY" apikey,        "CONSENT" consent,        "COUNT" count,        "EXPERIMENT" experiment,        "SDK_TYPE" sdk_type,        "DOMAIN" domain,        "DEPLOYMENT_ID" deployment_id,        "COUNTRY" country,        "REGION" region,        "BROWSER_FAMILY" browser_family,        "DEVICE_TYPE" device_type,        load_time,        load_no,        filename    from events)select * from raw    select extract(year from current_date)::int      as year,    select extract(year from current_date)::int year;    select * from staging.stg_date;    select * from mart.dim_date;    select * from raw.events;      create  table "analytics_db"."staging"."stg_event"    as  (with raw as (    select        "EVENT_ID" event_id,        "USER_ID" user_id,        "TYPE" type,        "RATE" rate,        "PARAMETERS" parameters,        "EVENT_TIME" event_time,        "WINDOW_START" window_start,        "APIKEY" apikey,        "CONSENT" consent,        "COUNT" count,        "EXPERIMENT" experiment,        "SDK_TYPE" sdk_type,        "DOMAIN" domain,        "DEPLOYMENT_ID" deployment_id,        "COUNTRY" country,        "REGION" region,        "BROWSER_FAMILY" browser_family,        "DEVICE_TYPE" device_type,        load_time,        load_no,        filename    from "analytics_db"."raw"."events")select    -- Unique & foreign keys    md5(cast(coalesce(cast(event_id as TEXT), '_dbt_utils_surrogate_key_null_') || '-' || coalesce(cast(event_time::date as TEXT), '_dbt_utils_surrogate_key_null_') as TEXT)) event_uq,    md5(cast(coalesce(cast(apikey as TEXT), '_dbt_utils_surrogate_key_null_') as TEXT)) company_fk,    md5(cast(coalesce(cast(country as TEXT), '_dbt_utils_surrogate_key_null_') as TEXT)) country_fk,    md5(cast(coalesce(cast(event_time::date as TEXT), '_dbt_utils_surrogate_key_null_') as TEXT)) date_fq,    -- Business keys    event_id,    user_id,    apikey company_id,    deployment_id,    -- Attributes (degenerative dimensions)    event_time event_dttm,    type event_type,    consent consent_status,    rate,    parameters,    sdk_type,    domain domain_name,    btrim(country, '"') country,    btrim(region, '"') region_code,    browser_family,    device_type,    count sample_count,    count/rate event_count    -- Metadata    'e42a7f1f-d92e-4921-a667-55d874585b1e' run_id,    current_timestamp ingest_dttm,    null update_dttm, -- transactional facts are immutable    filename originfrom raw  );-- 4758select   d.industry_back,   *from mart.fct_event fleft outer join mart.dim_company d on f.company_fk = d.company_skselect * from mart.fct_event;select * from raw.events where "COUNTRY" = '"AR"';------- exloring fct_event-- ok, we have 10 companies-- +------------------------------------+-- |company_id                          |-- +------------------------------------+-- |8f7daf45-489f-49e4-89c8-5f9a296b275c|-- |e1ac7e0c-53a5-4663-ac8a-ce98545817ec|-- |da552ba1-4bf9-42e7-befa-6c7f389f1b65|-- |49af23d9-0cad-4d42-8adc-744791443345|-- |e30f9a7e-1068-4cbe-ac99-41a618d38f48|-- |7725cda3-efd1-440b-8cc4-f80972acee43|-- |f921ddae-7bbc-4132-a9dd-04683bb89c2d|-- |5f67fa3a-b292-4bd2-b6e0-52257adc3a3b|-- |eb3fdba4-7b9b-4c5e-9a81-7ed2918ff46e|-- |29b2ad43-be6b-441a-9324-038b9268c9b6|-- +------------------------------------+select     tab.company_id, count(*) cnt from (select * from mart.fct_event) tab group by tab.company_idorder by cnt descwith raw as (    select *    from mart.fct_event), trf as (    select       lag(case when ) lag_consent_asked_given,       *    from raw)select * from raw;-- select--     e.*,--     case--         when e.event_type = 'consent.asked' then--             extract(--                 epoch from (first_value(case when event_type = 'consent.given' then event_dttm end) over (partition by user_id order by event_dttm rows between current row and unbounded following)- event_dttm)--             ) / 60.0--     end lag_consent_asked_given-- from fct_event e-- order by user_id, event_dttm;select--    first_value(case when event_type = 'consent.given' then event_dttm end) over (partition by user_id order by event_dttm rows between current row and unbounded following) user_consent_given_dttm,   *from fct_eventwith ordered as (    select        *,        lag(event_type) over (partition by user_id order by event_dttm) as prev_event_type,        lag(event_dttm)  over (partition by user_id order by event_dttm) as prev_event_dttm    from fct_event)select    user_id,    company_id,    deployment_id,    event_dttm,    event_type,    case        when event_type = 'consent.given' and prev_event_type = 'consent.asked'        then event_dttm - prev_event_dttm        else null    end as consent_response_timefrom ordered;with ordered as (    select        *,        lag(event_type) over (partition by user_id order by event_dttm) as prev_event_type,        lag(event_dttm)  over (partition by user_id order by event_dttm) as prev_event_dttm    from fct_event)select    prev_event_type,    user_id,    company_id,    deployment_id,    event_dttm,    event_type,    case        when event_type = 'consent.given' and prev_event_type = 'consent.asked'        then event_dttm - prev_event_dttm        else null    end  consent_response_timefrom ordered;with raw as (    select *    from fct_event), trf as (    select       case        when event_type = 'consent.asked' and event_type_next = 'consent.given'        then  floor(extract(epoch from (event_dttm_next - event_dttm)))       end lag_consent_asked_given,       *    from (        select            lead(event_type) over (partition by user_id,country,deployment_id, region_code, browser_family order by event_dttm) event_type_next, -- session_id simulation -> 18 events only            lead(event_dttm) over (partition by user_id,country,deployment_id, region_code, browser_family order by event_dttm) event_dttm_next, -- session_id            *        from raw    ) r), metrics as (    select        *     from)-- select * from rawselect * from trf-- Hi Adriano,-- I would need some additional information regarding the metric measuring the time to consent (consent.given - consent.asked time). I would need some confirmation:--  `consent.given` event are always non sampled events--  `consent.asked` events are real events with additional sampling information for this kind of events fot the hourly window (sampling rate and count).--   These events do not represent the first `consent.asked` event in this window (which would make the calculation feasible). This assumption comes from the fact that many `consent.given` events are generated before `consent.asked` events for these users.--   Each of the users in this set is using different browsers and devices, switching between them. On their interactions they also have different regions and different configurations (diployments_ids)--   Wihtout a session_id or similar identifier that would help match the `consent.asked` with its correspodning `consent.given` event this metric is not possible to accuratelly calculate.--   A possible solution to match the `consent.give` is to use a unique combination of several other attributes that tries to mimic the session (artition by user_id,country,deployment_id, region_code, browser_family) however this is still quite inacure (this yields 18 events, with average time to consetnt given of 57k seconds).-- FINDINGS - sampling made is quite inacurate to measure average consent.. do a comparison of event measured and dodal given-- sampling does not affect consent given (all consents are colletect fully)-- lag_consent_asked_given:-- ali ima vsak uporabnik samo 1 consent ask in given?-- each user has 1 consent.asked in this dataset!select user_id, event_type, count(*) cnt from mart.fct_event group by 1,2 order by cnt desc;-- a) SOME consent.asked do not have a corresponding consent given! if we striclty check at country and region_code (they should be the same), deploymnent_Id should also be the same-- bellow user is using 3 devices and 3 browsets HOWEVER for this specific consent.asked there is no matching consent.given (same browser, and device)select * from fct_event where user_id = '05de8beb-4dff-46fe-8cc0-efd549ec6d68';-- b)select * from fct_event where user_id = '05de8beb-4dff-46fe-8cc0-efd549ec6d68';select * from fct_event;-- C) REGION code seems to be unstable (or maybe the user is using a VPN browser) --> mogoce je deployment vezan na banner-- a user cannot travel from region `Hauts-de-France` to `Auvergne-Rhône-Alpes` in only 20 minutes ( device Mobile Safari)-- eg. 012a8523-b603-468e-a9f9-7d5bef8a4980-- AGGREGATE ON AN HOURLY LEVEL .. to also show the distribution..select * from fct_eventwith raw as (    select *    from {{ref('fct_event')}}),  trf as (    -- Calculate time-to-consent for `consent.asked` events.    -- Matching is based on `user_id` and chronological order (`event_dttm`) of events.    select       case        when event_type = 'consent.asked' and event_type_next = 'consent.given'            then  floor(extract(epoch from (event_dttm_next - event_dttm)))       end lag_consent_asked_given_second,       *    from (        select            lead(event_type) over (partition by user_id order by event_dttm) event_type_next,            lead(event_dttm) over (partition by user_id order by event_dttm) event_dttm_next,            *        from raw    ) r), totals as (    select        company_id,        -- General        sum(event_count) event_count,        sum(case when event_type = 'pageview' then event_count end) event_pageview_count,        sum(case when event_type = 'consent.asked' then event_count end) event_consent_asked_count,        sum(case when event_type = 'consent.given' then event_count end) event_consent_given_count,        sum(case when event_type = 'ui.action' then event_count end) event_ui_action_count,        avg(case when event_type = 'consent.asked' then lag_consent_asked_given_second end) lag_consent_asked_given_second_avg,        -- Consent        sum(case when event_type = 'consent.given' and consent_status = 'full opt-in' then event_count end) consent_given_full_opt_in_count,        sum(case when event_type = 'consent.given' and consent_status = 'opt-out' then event_count end) consent_given_opt_out_count,        sum(case when event_type = 'consent.given' and consent_status = 'partial opt-in' then event_count end) consent_given_partial_opt_in_count,        sum(case when event_type = 'consent.given' and consent_status = 'empty' then event_count end) consent_given_empty_count    from trf t    group by company_id), metrics as (   select      *,      round((event_consent_given_count::numeric / event_consent_asked_count::numeric),2) consent_conversion_rate   from totals)select    company_id,    -- lag_consent_asked_given_second_avg, -- unreliable data, metric is left out    event_count,    event_pageview_count,    event_consent_asked_count,    event_consent_given_count,    event_ui_action_count,    consent_given_full_opt_in_count,    consent_given_opt_out_count,    consent_given_partial_opt_in_count,    consent_given_empty_count,    consent_conversion_ratefrom  metrics mselect * from dim_company;drop table staging.stg_consent;select * from staging.stg_consent;--- dodaj countryselect * from dim_company;select distinct event_type  from fct_event tab;select distinct consent_status  from fct_event tab;select * from fct_event;select    consent_uq,    company_id,    event_dt,    event_count,    event_pageview_count,    event_consent_asked_count,    event_consent_given_count,    event_ui_action_count,    consent_given_full_opt_in_count,    consent_given_opt_out_count,    consent_given_partial_opt_in_count,    consent_given_empty_count,    consent_conversion_rate,    run_id,    ingest_dttm,    update_dttm,    originfrom {{ref('stg_consent')}};select    * from dim_dateselect * from dim_companyselect company_fk, * from fct_consentselect * from fct_consent; ---> !!! dulicates!select count(*) from fct_event;select count(*) from fct_consent;select * from report.consent_company_day;select * from fct_eventselect * from raw.events;select * from raw.country_and_industry;select * from mart.dim_company;select * from mart.dim_country;select * from mart.dim_date;select * from mart.fct_event;select * from mart.fct_consent;select * from report.consent_company_day;select    c.relname as table_name,    a.attname as column_namefrom pg_catalog.pg_attribute ajoin pg_catalog.pg_class c on a.attrelid = c.oidjoin pg_catalog.pg_namespace n on n.oid = c.relnamespacewhere n.nspname in ('mart', 'report')  and a.attnum > 0  and not a.attisdroppedorder by c.relname, a.attnum;select *from report.consent_company_daylimit 100;select * from raw.country_and_industry where "PUBLIC_API_KEY" is null;select * from raw.events where "EVENT_ID" is null;select * from raw.events where "EVENT_ID" = '';select * from raw.events where "EVENT_TIME" is null;select "EVENT_ID", count(*) cnt from raw.events group by 1 order by cnt desc;select "EVENT_TIME", count(*) cnt from raw.events group by 1 order by cnt desc;-- 2025-09-05-- 2025-09-06select     -- Date    d.date_day,    d.is_workday,    d.year,    d.month,    d.week_no,    -- Company     com.industry_front,    com.hq_country,    -- Metrics    comp.company_id,    comp.event_count,    comp.event_pageview_count,    comp.event_consent_asked_count,    comp.event_consent_given_count,    comp.event_ui_action_count,    comp.consent_given_full_opt_in_count,    comp.consent_given_opt_out_count,    comp.consent_given_partial_opt_in_count,    comp.consent_given_empty_count,    comp.consent_conversion_ratefrom {{ref('fct_consent')}} conleft outer join {{ref('dim_company')}} com on con.company_fk = com.company_skleft outer join {{ref('dim_date')}} dwhere 1=1    and current_date between com.valid_from and com.valid_to    and current_date between d.valid_from and d.valid_to;select * from report.consent_company_day;+----------+------------------------------------+-----------+--------------------+-------------------------+-------------------------+|date_day  |company_id                          |event_count|event_pageview_count|event_consent_asked_count|event_consent_given_count|+----------+------------------------------------+-----------+--------------------+-------------------------+-------------------------+|2025-09-05|7725cda3-efd1-440b-8cc4-f80972acee43|64 937      |58800               |5900                     |231                      |+----------+------------------------------------+-----------+--------------------+-------------------------+-------------------------+select * from raw.events where "APIKEY" = '7725cda3-efd1-440b-8cc4-f80972acee43'; -- 500 rowsselect count(*) from raw.events where "APIKEY" = '7725cda3-efd1-440b-8cc4-f80972acee43'; -- 500 rows-- event count = 104 736  --> fuk, to ni prav! sem jih kar nekaj zgubu! AJAAAAAA.. mo to so vsiselect    sum("COUNT"/"RATE") cntfrom raw.events where "APIKEY" = '7725cda3-efd1-440b-8cc4-f80972acee43';-- YEAY, correct-- Company raw count on a specific day-- cnt = 64937select sum("COUNT"/"RATE") cntfrom raw.eventswhere "APIKEY" = '7725cda3-efd1-440b-8cc4-f80972acee43'and date("EVENT_TIME") = '2025-09-05';-- fct_event--> ok, 104 736select sum(event_count) from fct_event where company_id = '7725cda3-efd1-440b-8cc4-f80972acee43';select sum(event_count) from fct_event where company_id = '7725cda3-efd1-440b-8cc4-f80972acee43' and date(event_dttm) = '2025-09-05'; -- ok, 64937select * from report.consent_company_day where company_id = '7725cda3-efd1-440b-8cc4-f80972acee43' and date_day = '2025-09-05'; -- ok, 64937-- Reporting table check-->     event_count = 64937select event_count, *from report.consent_company_daywhere company_id = '7725cda3-efd1-440b-8cc4-f80972acee43' and date_day = '2025-09-05'; -- ok, 64937select current_date;
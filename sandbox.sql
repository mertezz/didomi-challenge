select 1;select * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/events-company-1.csv';select  * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/*.csv';SELECT *FROM read_csv(  '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/*.csv',  filename = TRUE);SELECT * FROM glob('/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/*.csv');SELECT * FROM glob('/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/*/*');select * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/*.csv' union allselect * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/*.parquet';INSTALL postgres;LOAD postgres;ATTACH 'postgresql://ae_interview:password@localhost:5432/analytics_db' AS pg (TYPE postgres);-- ustvari testno tabelo v Postgresselect * from pg.raw.test_copy;create schema pg.raw;CREATE TABLE pg.raw.test_copy(id INT, name TEXT);insert into pg.raw.test_copy (id, name) values (1222,'fdsa');CREATE TABLE pg.raw.test_copy(id INT, name TEXT);CREATE TABLE pg.raw.test_copy2(id TEXT, name TEXT);-- poskusi COPY ->> ok, to dela! ampak pie v fajlCOPY (SELECT event_id, type FROM read_parquet('/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/*.parquet')) TO 'filename.txt'; --> write to file!!select * from pg.raw.test_copy2;select count(*) from pg.raw.test_copy2;truncate table pg.raw.test_copy2;select count(*) from pg.raw.events2;--- ok, this works!create table pg.raw.test_copy3 as select * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/*.parquet' where 1=0;copy pg.raw.test_copy3 from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/*.parquet';select count(*) from pg.raw.test_copy3 ;-- not supported sub-selectscopy pg.raw.test_copy2 from (    select event_id, type    FROM read_parquet('/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/*.parquet'));insert into pg.raw.test_copy2SELECT event_id, type FROM read_parquet('/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/*.parquet');select    tab.event_id, count(*) cntfrom (select * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/*.parquet') tabgroup by tab.event_idorder by cnt desc;select * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/events-company-1.csv';select * from pg.raw.events_csv;copy pg.raw.test_copy3 from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/*.parquet';----- benchmark-- 1. Generate synthetic data: 10M rows with 5 random columnscreate table bench_data asselect    range as id,    random() as col_a,    random() as col_b,    random() as col_c,    md5(random()::varchar) as col_d,    (random() * 1000)::int as col_efrom range(10000000);-- 2. create tablescreate table pg.raw.bench_insert as select * from bench_data where 1=0;create table pg.raw.bench_copy   as select * from bench_data where 1=0;-- 3. benchmark 1: insert into … select * from read_parquet-- 10,000,000 rows affected in 22 s 263 ms-- 10,000,000 rows affected in 25 s 46 msinsert into pg.raw.bench_insert select * from read_parquet('/tmp/gen_data_10m.parquet');-- 3. benchmark 2: copy … from parquet-- 10,000,000 rows affected in 21 s 479 ms-- 10,000,000 rows affected in 25 s 154 mscopy pg.raw.bench_copy from '/tmp/gen_data_10m.parquet' (format 'parquet');-- 4. sanity check: row countsselect  (select count(*) from pg.raw.bench_insert) as insert_count,  (select count(*) from pg.raw.bench_copy) as copy_count;  select current_timestamp;  ----  copy pg.raw.events2 from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/*.parquet';  select * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/*.parquet';  select * from '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/*.csv';drop table pg.raw.bench_copy;drop table pg.raw.bench_insert;drop table pg.raw.events2;drop table pg.raw.events_csv;select    *,    now()::timestamp as load_ts,    filenamefrom '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/csv/*.csv';-- EVENT_ID (string/UUID): Unique identifier for each event-- TYPE (string): Type of event. Common values include:-- consent.given - User has granted consent (most common: ~57% of events)-- pageview - Page view event (~27% of events)-- consent.asked - Consent prompt was shown (~14% of events)-- ui.action - User interface interaction (~3% of events)-- RATE (float): Sampling rate for the event (e.g., 0.1 means 10% sample rate, 1 means 100%)-- PARAMETERS (string/JSON): JSON object containing detailed event parameters. Structure varies by event type:-- For consent.given and consent.asked: Contains nested objects with purposes, vendors, and previous states-- For pageview and ui.action: Often empty-- EVENT_TIME (timestamp): When the event occurred (format: YYYY-MM-DD HH:MM:SS.mmm)-- WINDOW_START (timestamp): Start of the aggregation time window (format: YYYY-MM-DD HH:MM:SS.mmm)-- APIKEY (string/UUID): Company identifier - foreign key to PUBLIC_API_KEY in the company information file-- CONSENT (string): User's consent status (e.g., "full opt-in", "empty", "partial")-- COUNT (integer): Event count (often represents aggregated events)-- EXPERIMENT (string): Experiment/A-B test identifier (can be empty)-- SDK_TYPE (string): SDK type used to track the event (e.g., "sdk-mobile", "sdk-web")-- DOMAIN (string): Domain where the event occurred (e.g., "service1.org")-- DEPLOYMENT_ID (string): Deployment identifier (can be empty)-- COUNTRY (string): Country code(s) where event originated, enclosed in triple quotes (e.g., """ES""", """FR""")-- REGION (string): Region code where event originated, enclosed in triple quotes (e.g., """CM""", """MD""")-- BROWSER_FAMILY (string): Browser or SDK identifier (e.g., "Didomi SDK", "Chrome", "Safari")-- DEVICE_TYPE (string): Type of device (e.g., "smartphone", "desktop", "tablet")select * from pg.raw.events_csv;select event_id, count(*) cnt from pg.raw.events_csv group by 1 order by cnt desc;create table if not exists pg.raw.events(    event_id       varchar,    type           varchar,    rate           double precision,    parameters     varchar,    event_time     varchar,    window_start   varchar,    apikey         varchar,    consent        varchar,    count          bigint,    experiment     double precision,    sdk_type       varchar,    domain         varchar,    deployment_id  varchar,    country        varchar,    region         varchar,    browser_family varchar,    device_type    varchar);SELECT *, now()::timestamp AS load_ts, filename            FROM '{filename}'            LIMIT 0;drop table pg.raw.events;select * from pg.raw.events_csv;select * from pg.raw.test;drop table meta;create or replace table meta asselect unnest(['file1']) as filename, current_timestamp as load_time, 'loaded' status;select unnest(['file1', 'file2', 'file3', 'file4']) as filename, 'events' table_nameexceptselect    filename, table_namefrom metawhere status = 'loaded';select * from pg.raw.test8;select count(*) from pg.raw.test8;select * from meta;select * from load_metadata;SELECT database_name, schema_name, table_nameFROM duckdb_tables();WHERE table_name = 'load_metadata';select * from raw.load_metadata;select * from pg.raw.test9;-- insert into pg.raw.test9select t.*, current_timestamp as load_time, 'xx' as load_no, 'fdsafd' as filenameselect count(*)from    ['/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/events-company-9.parquet',    '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/input/events/parquet/events-company-9.parquet']    t;-- no, go. it creates a lock!ATTACH '/Users/matej/development/personal/didomi-challenge/challenges/analytics-engineering/scripts/load_metadata.duckdb'  as meta (READ_ONLY);detach meta; -- direcly after detaching it works againselect 1;select * from meta.load_metadata;